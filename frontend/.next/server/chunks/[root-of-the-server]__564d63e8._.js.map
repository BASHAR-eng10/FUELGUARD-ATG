{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bashar/Desktop/fuel_monitor/fuel-station-monitor/frontend/src/lib/middleware/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport jwt from 'jsonwebtoken';\r\n\r\nexport interface AuthenticatedUser {\r\n  userId: number;\r\n  email: string;\r\n  role: string;\r\n  canAccessAll: boolean;\r\n  stationId: number | null;\r\n  externalUserId: number;\r\n}\r\n\r\nexport function verifyToken(request: NextRequest): AuthenticatedUser {\r\n  const authHeader = request.headers.get('authorization');\r\n  const token = authHeader?.replace('Bearer ', '');\r\n  \r\n  if (!token) {\r\n    throw new Error('Access denied. No token provided.');\r\n  }\r\n\r\n  try {\r\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key') as AuthenticatedUser;\r\n    return decoded;\r\n  } catch (error) {\r\n    throw new Error('Invalid token.');\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AACA;;AAWO,SAAS,YAAY,OAAoB;IAC9C,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,QAAQ,YAAY,QAAQ,WAAW;IAE7C,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI;QACF,MAAM,UAAU,uIAAA,CAAA,UAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,UAAU,IAAI;QAC5D,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF","debugId":null}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bashar/Desktop/fuel_monitor/fuel-station-monitor/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined\r\n}\r\n\r\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\r\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bashar/Desktop/fuel_monitor/fuel-station-monitor/frontend/src/lib/auth/tokenManager.ts"],"sourcesContent":["// src/lib/auth/tokenManager.ts - User token management utilities\r\n// \"use server\"\r\nimport { prisma } from '../prisma';\r\nimport jwt from 'jsonwebtoken';\r\n\r\ninterface StoredSession {\r\n  access_token: string;\r\n  refresh_token: string;\r\n  created_at: string;\r\n}\r\n\r\n// Get user's external API tokens from database\r\nexport async function getUserTokens(userId: string): Promise<StoredSession | null> {\r\n  try {\r\n    const session = await prisma.systemCache.findUnique({\r\n      where: { \r\n        key: `user_session_${userId}`,\r\n      },\r\n      select: {\r\n        value: true,\r\n        expires_at: true\r\n      }\r\n    });\r\n    \r\n    if (session && session.expires_at && session.expires_at > new Date()) {\r\n      const tokens: StoredSession = JSON.parse(session.value);\r\n      console.log(`üîë Retrieved tokens for user ${userId}`);\r\n      return tokens;\r\n    }\r\n    \r\n    console.log(`‚ö†Ô∏è No valid session found for user ${userId}`);\r\n    return null;\r\n  } catch (error) {\r\n    console.warn('Failed to get user tokens:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Extract user ID from JWT token\r\nexport function getUserIdFromToken(authHeader: string | null): string | null {\r\n  try {\r\n    const token = authHeader?.replace('Bearer ', '');\r\n    if (!token) return null;\r\n    \r\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key') as any;\r\n    return decoded.userId?.toString() || null;\r\n  } catch (error) {\r\n    console.warn('Failed to decode token:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Make authenticated request to external API using user's stored tokens\r\nexport async function makeAuthenticatedExternalRequest(\r\n  userId: string, \r\n  endpoint: string, \r\n  options: RequestInit = {}\r\n) {\r\n  const tokens = await getUserTokens(userId);\r\n  \r\n  if (!tokens) {\r\n    throw new Error('No valid session found. Please login again.');\r\n  }\r\n  \r\n  const url = `${process.env.EXTERNAL_API_URL || 'http://78.189.54.28:3800'}${endpoint}`;\r\n\tconsole.log(`Making request to ${url} with token: ${tokens.access_token}`);\r\n\r\n\toptions.headers = {\r\n\t\t'Content-Type': 'application/json',\r\n\t\t'Accept': 'application/json',\r\n\t\t'Authorization': `${tokens.access_token}`,\r\n\t\t...options.headers\r\n\t};\r\n\r\n  const response = await fetch(url, options);\r\n\r\n  if (!response.ok) {\r\n    if (response.status === 401) {\r\n      // Token expired, could implement refresh logic here\r\n      throw new Error('Session expired. Please login again.');\r\n    }\r\n    throw new Error(`Request failed: ${response.status} ${response.statusText}`);\r\n  }\r\n  \r\n  return response.json();\r\n}\r\n\r\n// Clear user session\r\nexport async function clearUserSession(userId: string): Promise<void> {\r\n  try {\r\n    await prisma.systemCache.deleteMany({\r\n      where: { key: `user_session_${userId}` }\r\n    });\r\n    console.log(`üóëÔ∏è Session cleared for user ${userId}`);\r\n  } catch (error) {\r\n    console.warn('Failed to clear user session:', error);\r\n  }\r\n}\r\n\r\n// Check if user session is valid\r\nexport async function isSessionValid(userId: string): Promise<boolean> {\r\n  const tokens = await getUserTokens(userId);\r\n  return tokens !== null;\r\n}\r\n"],"names":[],"mappings":"AAAA,iEAAiE;AACjE,eAAe;;;;;;;;AACf;AACA;;;AASO,eAAe,cAAc,MAAc;IAChD,IAAI;QACF,MAAM,UAAU,MAAM,kIAAA,CAAA,SAAM,CAAC,WAAW,CAAC,UAAU,CAAC;YAClD,OAAO;gBACL,KAAK,CAAC,aAAa,EAAE,QAAQ;YAC/B;YACA,QAAQ;gBACN,OAAO;gBACP,YAAY;YACd;QACF;QAEA,IAAI,WAAW,QAAQ,UAAU,IAAI,QAAQ,UAAU,GAAG,IAAI,QAAQ;YACpE,MAAM,SAAwB,KAAK,KAAK,CAAC,QAAQ,KAAK;YACtD,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,QAAQ;YACpD,OAAO;QACT;QAEA,QAAQ,GAAG,CAAC,CAAC,mCAAmC,EAAE,QAAQ;QAC1D,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,IAAI,CAAC,8BAA8B;QAC3C,OAAO;IACT;AACF;AAGO,SAAS,mBAAmB,UAAyB;IAC1D,IAAI;QACF,MAAM,QAAQ,YAAY,QAAQ,WAAW;QAC7C,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,UAAU,uIAAA,CAAA,UAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,UAAU,IAAI;QAC5D,OAAO,QAAQ,MAAM,EAAE,cAAc;IACvC,EAAE,OAAO,OAAO;QACd,QAAQ,IAAI,CAAC,2BAA2B;QACxC,OAAO;IACT;AACF;AAGO,eAAe,iCACpB,MAAc,EACd,QAAgB,EAChB,UAAuB,CAAC,CAAC;IAEzB,MAAM,SAAS,MAAM,cAAc;IAEnC,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,MAAM,GAAG,QAAQ,GAAG,CAAC,gBAAgB,IAAI,6BAA6B,UAAU;IACvF,QAAQ,GAAG,CAAC,CAAC,kBAAkB,EAAE,IAAI,aAAa,EAAE,OAAO,YAAY,EAAE;IAEzE,QAAQ,OAAO,GAAG;QACjB,gBAAgB;QAChB,UAAU;QACV,iBAAiB,GAAG,OAAO,YAAY,EAAE;QACzC,GAAG,QAAQ,OAAO;IACnB;IAEC,MAAM,WAAW,MAAM,MAAM,KAAK;IAElC,IAAI,CAAC,SAAS,EAAE,EAAE;QAChB,IAAI,SAAS,MAAM,KAAK,KAAK;YAC3B,oDAAoD;YACpD,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,SAAS,MAAM,CAAC,CAAC,EAAE,SAAS,UAAU,EAAE;IAC7E;IAEA,OAAO,SAAS,IAAI;AACtB;AAGO,eAAe,iBAAiB,MAAc;IACnD,IAAI;QACF,MAAM,kIAAA,CAAA,SAAM,CAAC,WAAW,CAAC,UAAU,CAAC;YAClC,OAAO;gBAAE,KAAK,CAAC,aAAa,EAAE,QAAQ;YAAC;QACzC;QACA,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,QAAQ;IACtD,EAAE,OAAO,OAAO;QACd,QAAQ,IAAI,CAAC,iCAAiC;IAChD;AACF;AAGO,eAAe,eAAe,MAAc;IACjD,MAAM,SAAS,MAAM,cAAc;IACnC,OAAO,WAAW;AACpB","debugId":null}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bashar/Desktop/fuel_monitor/fuel-station-monitor/frontend/src/app/api/stations/%5Bid%5D/tanks/route.ts"],"sourcesContent":["// /ak4tek/tanks/\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { verifyToken } from '@/lib/middleware/auth';\r\nimport { makeAuthenticatedExternalRequest } from '@/lib/auth/tokenManager';\r\n\r\n// GET /api/stations - Get all stations using user's stored tokens\r\nexport async function GET(request: NextRequest,\r\n\t  { params }: { params: Promise<{ id: string }> }\r\n) {\r\n  try {\r\n\t\tconst {id } = await params;\r\n    // Verify user token\r\n    const user = verifyToken(request);\r\n    console.log(`üîê Authenticated user: ${user.email} (${user.role})`);\r\n\r\n    // Make request to external API using user's stored tokens\r\n    const tanks = await makeAuthenticatedExternalRequest(\r\n      user.userId.toString(),\r\n      '/ak4tek/tanks/'\r\n    );\r\n\t\tif (!Array.isArray(tanks.data)) {\r\n\t\t\tconsole.error('Invalid tanks data format:', tanks.data);\r\n\t\t\treturn NextResponse.json({\r\n\t\t\t\tsuccess: false,\r\n\t\t\t\terror: 'Invalid tanks data format'\r\n\t\t\t}, { status: 400 });\r\n\t\t}\r\n\r\n\t\t// determine the station_id based on the tanks ewuralicense\r\n    // Make request to external API using user's stored tokens\r\n    const stations = await makeAuthenticatedExternalRequest(\r\n      user.userId.toString(),\r\n      '/stationinfo/all'\r\n    );\r\n\t\t// filter by station id\r\n\t\tconst filteredTanks = tanks.data?.filter((tank: any) => {\r\n\t\t\tconst station = stations.data.find((s: any) => s.EWURALicenseNo === tank.EWURALicenseNo);\r\n\t\t\treturn station ? station.id === Number(id) : false;\r\n\t\t});\r\n\r\n\t\t// Filter only latest tanks by grouping by tank ID and getting the most recent entry\r\n\t\tconst latestTanks = filteredTanks.reduce((acc: any[], tank: any) => {\r\n\t\t\tconst existingIndex = acc.findIndex(existing => existing.tank_id === tank.tank_id);\r\n\t\t\t\r\n\t\t\tif (existingIndex === -1) {\r\n\t\t\t\t// First occurrence of this tank\r\n\t\t\t\tacc.push(tank);\r\n\t\t\t} else {\r\n\t\t\t\t// Compare timestamps and keep the latest\r\n\t\t\t\tconst existingDate = new Date(acc[existingIndex].timestamp || acc[existingIndex].created_at || acc[existingIndex].date || 0);\r\n\t\t\t\tconst currentDate = new Date(tank.timestamp || tank.created_at || tank.date || 0);\r\n\t\t\t\t\r\n\t\t\t\tif (currentDate > existingDate) {\r\n\t\t\t\t\tacc[existingIndex] = tank;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn acc;\r\n\t\t}, []) || [];\r\n\r\n\r\n\t\t// const revisedTanks = latestTanks.map((tank: any) => {\r\n\t\t// \tconst station = stations.data.find((s: any) => s.EWURALicenseNo === tank.EWURALicenseNo);\r\n\t\t// \treturn {\r\n\t\t// \t\t...tank,\r\n\t\t// \t\tstation_id: station ? station.id : null\r\n\t\t// \t};\r\n\t\t// });\r\n\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: latestTanks,\r\n      source: 'external_api_user_authenticated',\r\n      timestamp: new Date().toISOString(),\r\n      user: {\r\n        email: user.email,\r\n        role: user.role\r\n      }\r\n    });\r\n  } catch (error: any) {\r\n    console.error('Tanks API error:', error);\r\n    \r\n    if (error.message.includes('token') || error.message.includes('Session')) {\r\n      return NextResponse.json({\r\n        success: false,\r\n        error: error.message\r\n      }, { status: 401 });\r\n    }\r\n    \r\n    return NextResponse.json({\r\n      success: false,\r\n      error: 'Failed to fetch tanks',\r\n      details: error.message\r\n    }, { status: 500 });\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;AACjB;AACA;AACA;;;;AAGO,eAAe,IAAI,OAAoB,EAC3C,EAAE,MAAM,EAAuC;IAEhD,IAAI;QACJ,MAAM,EAAC,EAAE,EAAE,GAAG,MAAM;QAClB,oBAAoB;QACpB,MAAM,OAAO,CAAA,GAAA,8IAAA,CAAA,cAAW,AAAD,EAAE;QACzB,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,KAAK,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC;QAEjE,0DAA0D;QAC1D,MAAM,QAAQ,MAAM,CAAA,GAAA,gJAAA,CAAA,mCAAgC,AAAD,EACjD,KAAK,MAAM,CAAC,QAAQ,IACpB;QAEJ,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM,IAAI,GAAG;YAC/B,QAAQ,KAAK,CAAC,8BAA8B,MAAM,IAAI;YACtD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACxB,SAAS;gBACT,OAAO;YACR,GAAG;gBAAE,QAAQ;YAAI;QAClB;QAEA,2DAA2D;QACzD,0DAA0D;QAC1D,MAAM,WAAW,MAAM,CAAA,GAAA,gJAAA,CAAA,mCAAgC,AAAD,EACpD,KAAK,MAAM,CAAC,QAAQ,IACpB;QAEJ,uBAAuB;QACvB,MAAM,gBAAgB,MAAM,IAAI,EAAE,OAAO,CAAC;YACzC,MAAM,UAAU,SAAS,IAAI,CAAC,IAAI,CAAC,CAAC,IAAW,EAAE,cAAc,KAAK,KAAK,cAAc;YACvF,OAAO,UAAU,QAAQ,EAAE,KAAK,OAAO,MAAM;QAC9C;QAEA,oFAAoF;QACpF,MAAM,cAAc,cAAc,MAAM,CAAC,CAAC,KAAY;YACrD,MAAM,gBAAgB,IAAI,SAAS,CAAC,CAAA,WAAY,SAAS,OAAO,KAAK,KAAK,OAAO;YAEjF,IAAI,kBAAkB,CAAC,GAAG;gBACzB,gCAAgC;gBAChC,IAAI,IAAI,CAAC;YACV,OAAO;gBACN,yCAAyC;gBACzC,MAAM,eAAe,IAAI,KAAK,GAAG,CAAC,cAAc,CAAC,SAAS,IAAI,GAAG,CAAC,cAAc,CAAC,UAAU,IAAI,GAAG,CAAC,cAAc,CAAC,IAAI,IAAI;gBAC1H,MAAM,cAAc,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,UAAU,IAAI,KAAK,IAAI,IAAI;gBAE/E,IAAI,cAAc,cAAc;oBAC/B,GAAG,CAAC,cAAc,GAAG;gBACtB;YACD;YAEA,OAAO;QACR,GAAG,EAAE,KAAK,EAAE;QAGZ,wDAAwD;QACxD,6FAA6F;QAC7F,YAAY;QACZ,aAAa;QACb,4CAA4C;QAC5C,MAAM;QACN,MAAM;QAGJ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;YACN,QAAQ;YACR,WAAW,IAAI,OAAO,WAAW;YACjC,MAAM;gBACJ,OAAO,KAAK,KAAK;gBACjB,MAAM,KAAK,IAAI;YACjB;QACF;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,oBAAoB;QAElC,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,YAAY,MAAM,OAAO,CAAC,QAAQ,CAAC,YAAY;YACxE,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,OAAO,MAAM,OAAO;YACtB,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,OAAO;YACP,SAAS,MAAM,OAAO;QACxB,GAAG;YAAE,QAAQ;QAAI;IACnB;AACF","debugId":null}}]
}